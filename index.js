// 1. Напишите функцию deepEqual для проверки двух обьектов на идентичность. Пример:

function deepEqual(obj1, obj2) {
  //за допомогою JSON.stringify можна перетворити об'єкти в рядки і порівняти їх, однак якщо пари в об'єктах будуть мати різний порядок, то результат буде false.
  if (JSON.stringify(obj1) === JSON.stringify(obj2)) {
    return true;
  } else {
    return false;
  }
}
//щоб порядок пар в об'єкті не враховувався, перевірку можна здійснити за допомогою наступної функції
function deepEqual(obj1, obj2) {
  //для початку створимо масиви з ключами кожного об'єкту та відсортуємо їх
  const obj1Keys = Object.keys(obj1).sort();
  const obj2Keys = Object.keys(obj2).sort();
  //для початку перевіримо чи кількість ключів рівна, інакше об'єкти ніяк не можуть бути рівними
  if (obj1Keys.length !== obj2Keys.length) {
    return false;
    //після чого перевіряємо відповідність ключ-значення в об'єктах, перевірка відбувається по порядку, оскільки раніше відбулось сортування
    //за допомогою every перевіряємо чи задовольняють усі пари умову, якщо буде хоча б 1 відмінність, буде отримано false
  } else {
    const areEqual = obj1Keys.every((key, index) => {
      const objValue1 = obj1[key];
      const objValue2 = obj2[obj2Keys[index]];
      return objValue1 === objValue2;
    });
    //на підставі раніше отриманого значення повертаємо результат
    if (areEqual) {
      return true;
    } else {
      return false;
    }
  }
}

// 2. Напишите функцию генератор chunkArray,
// которая возвращает итератор возвращающий части массива указанной длинны.

function makeIterator(array, num) {
  //створили масив значень
  let retArr = []
  return {
    //повертаємо ітератор
    next() {
      //якщо не буде вистачати на повний масив з num значень, то створюємо масив з тим що залишилось
      if (array.length < num) {
        retArr = array;
      }
      //видаляємо з масиву перші num елементів та повертаємо їх
      retArr = array.splice(0, num);

      //перевіряємо чи був створений масив чи вже нічого не залишилось
      return retArr.length > 0
        ? {
            value: retArr,
            done: false,
          }
        : {
            value: undefined,
            done: true,
          };
    },
  };
}
const it = makeIterator([1, 2, 3, 4, 5, 6, 7, 8], 3);

//перший крок щоб отримати значення для майбутнього створення циклу
let step = it.next();
console.log(step);
//виконання циклу доки не повернемо всі частини масиву
while (!step.done) {
  step = it.next();
  console.log(step);
}

// 3. Напишите функцию обертку, которая на вход принимает массив функций и их параметров, а возвращает массив результатов их выполнения. Количество аргументов исполняемой функции не ограничено!

async function bulkRun(functions) {
  //створили масив з результатами які будуть повернуті
  const results = [];
  //створюємо новий проміс для кожної функції з аргументами оскільки будемо чекати виконання функції щоб в подальшому додати результат до масиву
  for (const [func, args] of functions) {
    const functionResult = await new Promise((resolve) => {
      //викликаємо функцію, в яку передаємо усі наявні аргументи за допомогою ... і чекаємо результат виконання кожної функції
      func(...args, (result) => {
        //тут буде отриманий результат значення якого буде присвоєне для functionResult
        resolve(result);
      });
    });
    //додаємо до масиву результати виконання функцій
    results.push(functionResult);
  }

  return results;
}

const f1 = (cb) => {
  cb(1);
};

const f2 = (a, cb) => {
  cb(a);
};

const f3 = (a, b, cb) => {
  setTimeout(() => cb([a, b]), 1000);
};

//виконуємо функцію і відразу після її виконання виводимо результат
bulkRun([
  [f1, []],
  [f2, [2]],
  [f3, [3, 4]]

]).then(console.log);

// 4. Напишите метод arrayToObject, который превращает массив в объект (использовать рекурсию). Пример:

function arrayToObject(arr) {
  //створив об'єкт який буду повертати коли заповню
  let obj = {};

  //беру кожну пару з масиву та перевіряю чи є другий елемент в цій парі масивом
  for (const [key, value] of arr) {
    if (Array.isArray(value)) {
      //якщо другий елемент виявляється масивом, це означає що необхідно рухатись в цьому напрямі і далі його розгортати, тому використовуємо рекурсію
      //таким чином цей масив буде перетворено на об'єкт і він буде значенням відповідного ключа, при створенні якого почалась рекурсія
      obj[key] = arrayToObject(value);
    } else {
      //якщо другий елемент не масив то все просто - пара створена
      obj[key] = value;
    }
  }
  //повернув готовий об'єкт
  return obj;
}

let arr = [
  ["name", "developer"],
  ["age", 5],
  [
    "skills",
    [
      ["html", 4],
      ["css", 5],
      ["js", [["html", 4], ["css", 5], ["js", 5]]],
    ],
  ],
];
//виводимо результат
console.log(arrayToObject(arr));

// 5. Написать обратный метод (см. задачу 4) objectToArray, который из объекта создаст массив.

function objectToArray(obj) {

  //за допомогою entries перетворив об'єкт в масив з масивами, в якому кожний підмасив має структуру [ключ, значення]
  //однак об'єкт може містити всередині інші об'єкти, які і потрібно буде конвертувати за допомогою рекурсії
  //після чого беру кожний з цих підмасивів за допомогою map та виконую операції із елементами підмасиву
  //використовуємо return на початку тому що за допомогою map повернемо
  return Object.entries(obj).map(([key, value]) => {
    //перший елемент, тобто ключ, точно не буде об'єктом, а от до другого значення можуть бути питання
    //якщо це масив то його значення просто присвоюємо, виконуємо цю перевірку включно бо typeof повертає object і на об'єкт і на масив
    if (typeof value === "object" && !Array.isArray(value)) {
      //якщо виявиться що цей елемент є теж об'єктом, то за допомогою рекурсії ми його розгорнемо і додамо це значення до ключа, звідки ця рекурсія почалась
      return [key, objectToArray(value)];
    } else {
      //якщо це звичайне значення то просто створюємо підмасив
      return [key, value];
    }
  });
}

let arr = objectToArray({
  name: "developer",
  age: 5,
  skills: {
    html: 4,
    css: 5,
    js: 5,
  },
});

//вивід в консоль виконую наступним способом, щоб продемонструвати всі вкладені елементи масивів
console.dir(arr, { depth: null, colors: true, maxArrayLength: null });

// 6. Есть функция primitiveMultiply, которая умножает числа, но случайным образом может выбрасывать исключения типа: NotificationException, ErrorException. Задача написать функцию обертку которая будет повторять вычисление при исключении NotificationException, но прекращать работу при исключениях ErrorException

function NotificationException() {}
function ErrorException() {}
function primitiveMultiply(a, b) {
  const rand = Math.random();
  if (rand < 0.5) {
    return a * b;
  } else if(rand > 0.85) {
    throw new ErrorException()
  } else {
    throw new NotificationException()
  }
}

function reliableMultiply(a, b) {
  // Мій код
  let result;
  //створюю цикл в якому буду чекати отримання результату який є числом
  while(typeof(result) !== "number"){
    //створив try catch щоб ловити помилки
    try {
      result = primitiveMultiply(a, b)
      //якщо потрібний результат отримано то повертаю його
      return result;
    } catch (error) {
      //якщо помилка то виводжу її назву в консоль і перевіряю що
      console.error(error)
      //перевіряю чи є отримана помилка екземпляром класу ErrorException, якщо це так, то завершую виконання повертаючи рядок з повідомленням про помилку
      if(error instanceof ErrorException) {
        return "ErrorException!!!"
      }
      //інакше цикл продовжиться
    }
  }
}

// console.log(reliableMultiply(8, 8));

// 7.  Напишите функцию, которая берет объект любой вложенности и преобразует ее в единую плоскую карту с разными уровнями, разделенными косой чертой ( '/').

//створив функцію в якій один з параметрів має задане значення, якщо не буде передано інше
function mapObject(obj, parentKey = "") {
  let result = {};
  //створив новий об'єкт та працюю з кожним ключем переданого об'єкту
  for (let key in obj) {
    //створюю новий ключ і перевіряю чи попередній ключ не пустий, тобто чи це вже вкладення чи ще початок об'єкта
    //якщо ключ не пустий то додаю наступне значення ключа через слеш
    //інакше створюємо новий ключ і заглиблюємось у вкладення
    const newKey = parentKey ? `${parentKey}/${key}` : key;
    //якщо значення яке відповідає даному ключу об'єкт і не масив..
    if (typeof obj[key] === "object" && !Array.isArray(obj[key])) {
      //...то нову пару ключ значення створюємо за допомогою рекурсії
      //викликаючи цю функцію з аргументами (об'єкт який буде розгортатись, ключ який відображає шар на якому ми знаходимось)
      Object.assign(result, mapObject(obj[key], newKey));
    } else {
      //до ключа який відображає шлях присвоюємо відповідне значення
      result[newKey] = obj[key];
    }
  }

  return result;
}

const obj = {
  a: {
    b: {
      c: 12,
      d: "Hello World",
    },
    e: [1, 2, 3],
    g: {
      r: 12,
      d: "Hello World",
    },
  },
};

const result = mapObject(obj);
console.log(result);

// 8. Напишите функцию combos, которая принимает положительное целое число num и возвращает массив массивов положительных целых чисел, где сумма каждого массива равна  num.  Массивы не должны повторяться.

function combos(num) {
  const result = [];

  // Всередині функції створимо іншу функцію яку будемо використовувати для рекурсії
  //параметрами функції визначимо remaining - значння яке має бути отримане або залишок який ще потрібно
  //currentCombo - значення яке є на даний момент та start - початок створення комбінації
  function findCombos(remaining, currentCombo, start) {
    //перевіряємо чи вийшло набрати комбінацію
    if (remaining === 0) {
      result.push(currentCombo.slice()); 
      //додаємо створену комбінацію використовуючи slice, щоб додати саме новий масив, а не посилання на наявний

      return;
    }
    //починаємо створення комбінацій, для цього використовуємо цикл 
    //переглядаємо усі можливі числа від початку до remaining, тобто до залишку
    for (let i = start; i <= remaining; i++) {
      //додаємо число до поточної комбінації з яким будемо створювати продовження комбінації 
      currentCombo.push(i);
      //викликаємо рекурсивно функцію з новими параметрами, тобто такими де залишок вже зменшений на значення i
     //а також комбо містить і
      findCombos(remaining - i, currentCombo, i);
      //після того як всі комбінації з даним і було сформовано та додано, прибираємо цей елемент з масиву щоб продовжити пошук з новим значенням
      currentCombo.pop();
    }
  }
  //викликаємо функцію яка створює комбінації, початкової комбінації ще немає, початок з 1
  findCombos(num, [], 1); 
  return result;
}

console.log(combos(3));
console.log(combos(10));

// 9.  Напишите функцию add, которая бы работала следующим образом add(1)(2)(7)...(n). Количество последовательных визовов неограничено.

function add(a) {
  //оголошуємо функцію яка буде приймати усі наступні значення та буде додавати їх до значення яке було передано першим
  function sum(b) {
    a = a + b;
    //повертаємо цю ж функцію щоб додати усі наступні значення
    return sum;
  }
  //використовуємо щоб отримати значення а яке було створено за допомогою функції
    sum.toString = function () {
    return a;
  };
  // з цього моменту починається додавання, тобто повертаємо функцію sum якщо є що додавати;
  return sum;
}

console.log(Number(add(1)(2))); // == 3
console.log(Number(add(1)(2)(5))); // == 8
console.log(Number(add(1)(2)(-3)(4))); //  == 4
console.log(Number(add(1)(2)(3)(4)(-5))); // == 5
